package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	args := os.Args[1:]

	if len(args) != 2 {
		fmt.Printf("Usage: %s <pkg-file-path> <output-file.go>\n", os.Args[0])
		os.Exit(1)
	}

	outputFile := args[1]
	fileInfo, err := os.Stat(outputFile)
	if err != nil && !os.IsNotExist(err) {
		log.Fatal(err)
	}

	path, err := filepath.Abs(args[0])
	if err != nil {
		log.Fatal(err)
	}
	log.Printf("Processing files at %s", path)

	filter := func(fi os.FileInfo) bool {
		// exclude test files
		if strings.HasSuffix(fi.Name(), "_test.go") {
			return false
		}

		// exclude pre-existing generated unmarshalers
		if fileInfo != nil && os.SameFile(fi, fileInfo) {
			return false
		}

		return true
	}

	pkgs, err := parsePackagesFromPath(path, filter)
	if err != nil {
		log.Fatal(err)
	}

	for _, pkg := range pkgs {
		log.Printf("Processing package %q", pkg.Name)
		body := unmarshalersForPackage(pkg)
		if body != "" {
			n, err := writeInto(outputFile, body)
			if err != nil {
				log.Fatal(err)
			}
			log.Printf("%d bytes written into %s", n, outputFile)
		}
	}
}

func writeInto(filePath, content string) (int, error) {
	f, err := os.Create(filePath)
	if err != nil {
		return 0, err
	}
	defer f.Close()

	return f.WriteString(content)
}

func parsePackagesFromPath(path string, filter func(fi os.FileInfo) bool) (map[string]*ast.Package, error) {
	fset := token.NewFileSet()

	return parser.ParseDir(fset, path, filter, 0)
}

func unmarshalersForPackage(pkg *ast.Package) string {
	i := newInspector()

	i.processPackage(pkg)

	types := i.typesWithoutUnmarshaler()

	if len(types) == 0 {
		return ""
	}

	header := fmt.Sprintf(`package %s

// Code generated by gen/unmarshalers.go. DO NOT EDIT.

import (
	"encoding/json"
)
`, pkg.Name)

	body := ""
	for _, typeName := range types {
		body += unmarshalerForType(typeName)
	}

	return header + body
}

func unmarshalerForType(typeName string) string {
	return fmt.Sprintf(`
// UnmarshalJSON implements non-strict json.Unmarshaler.
func (v *%[1]s) UnmarshalJSON(b []byte) error {
	type t %[1]s
	return json.Unmarshal(b, (*t)(v))
}
`, typeName)
}
